<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>WebGPU Life</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <canvas width="512" height="512"></canvas>
    <script type="module">
      const canvas = document.querySelector("canvas");

      // WebGPU code 여기서부터 시작
      if (!navigator.gpu) {
        throw new Error("WebGPU not supported on this browser.");
      }

      // GPUAdapter 요청
      const adapter = await navigator.gpu?.requestAdapter();
      if (!adapter) {
        throw new Error("No appropriate GPUAdapter found.");
      }

      // GPUDevice 요청
      const device = await adapter.requestDevice();

      if (!device) {
        throw new Error("No appropriate GPUDevice found.");
      }

      // GPUContext 설정
      const context = canvas.getContext("webgpu");
      const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
      context.configure({
        device: device,
        format: canvasFormat,
      });

      const module = device.createShaderModule({
        label : "rgb triangle",
        code : `
          struct Vertex_output {
            @builtin(position) position : vec4f,
            @location(0) color : vec4f,
          };

          @vertex
          fn vertex_shader(@builtin(vertex_index) vertexIndex : u32) -> Vertex_output {
            let pos = array(
              vec2<f32>(0.0, 0.5),
              vec2<f32>(0.5, -0.5),
              vec2<f32>(-0.5, -0.5)
            );

            var color = array<vec4f, 3>(
              vec4f(1.0, 0.0, 0.0, 1.0),
              vec4f(0.0, 0.0, 1.0, 1.0),
              vec4f(0.0, 1.0, 0.0, 1.0)
            );

            var vsOutput : Vertex_output;
            vsOutput.position = vec4f(pos[vertexIndex], 0.0, 1.0);
            vsOutput.color = color[vertexIndex];
            return vsOutput;
          }
          
          @fragment
          fn fragment_shader(fsInput : Vertex_output) -> @location(0) vec4f{
            return fsInput.color;
          }
        `
      })

      const pipeline = device.createRenderPipeline({
        label : "red triangle",
        layout : 'auto',
        vertex : {
          module : module,
          entryPoint : "vertex_shader"
        },
        fragment : {
          module : module,
          entryPoint : "fragment_shader",
          targets : [
            {
              format : canvasFormat
            }
          ]
        },
      })

      const renderPassDescriptor = {
        label: "basic renderPass",
        colorAttachments: [
          {
            clearValue: [0.3, 0.3, 0.3, 1],
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
      }

      function render(){
        renderPassDescriptor.colorAttachments[0].view = context.getCurrentTexture().createView();

        const encoder = device.createCommandEncoder({ label : "encoder"});

        const pass = encoder.beginRenderPass(renderPassDescriptor);
        pass.setPipeline(pipeline);
        pass.draw(3);
        pass.end();

        const commandBuffer = encoder.finish();
        device.queue.submit([commandBuffer]);
      }

      const observer = new ResizeObserver(entries => {
        for (const entry of entries){
          const canvas = entry.target;
          const width = entry.contentBoxSize[0].inlineSize;
          const height = entry.contentBoxSize[0].blockSize;
          canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
          canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));

          render();
        }
      });

      observer.observe(canvas);

    </script>
  </body>
</html>
